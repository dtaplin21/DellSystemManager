'use client'

import { useState, useRef, useEffect, useMemo, useCallback } from 'react'
import { useZoomPan } from '@/hooks/use-zoom-pan'
import { useFlexibleResize } from '@/hooks/use-flexible-resize'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Switch } from '@/components/ui/switch'
import { Slider } from '@/components/ui/slider'
import { ChevronLeft, ChevronRight, ZoomIn, ZoomOut, Maximize2, RotateCcw, Download, Plus, Settings, Trash2, Edit3 } from 'lucide-react'
import CreatePanelModal from './CreatePanelModal'
import PanelAIChat from './PanelAIChat'
import PanelSidebar from '@/components/panel-layout/panel-sidebar'
import { exportToDXF } from '@/lib/dxf-helpers'
import { exportToJSON } from '@/lib/dxf-helpers'
import { parseExcelPanels, generateTemplateFile } from '@/lib/excel-import'
import { applyPanelSnapping, createCustomResizeHandles, ResizeConstraints } from '@/lib/resize-utils'
import { assignRollNumbersWestToEast } from '@/lib/panel-label-utils'
import { Stage, Layer, Rect, Group } from 'react-konva'
import { Line } from 'react-konva/lib/ReactKonvaCore'
import { Text } from 'react-konva/lib/ReactKonvaCore'
import type { Panel } from '../../types/panel'
import { GRID_CELL_SIZE_FT, WORLD_WIDTH_FT, WORLD_HEIGHT_FT, SNAP_THRESHOLD_FT } from '@/components/panel-layout/panel-grid'

interface PanelLayoutProps {
  mode: 'manual' | 'auto'
  projectInfo: {
    projectName: string
    location: string
    description: string
    manager: string
    material: string
  }
}

interface ResizeSettings {
  minWidth: number
  minHeight: number
  maxWidth?: number
  maxHeight?: number
  lockAspectRatio: boolean
  aspectRatio: number
  snapToGrid: boolean
  gridSize: number
  snapToOtherPanels: boolean
  snapThreshold: number
  enableVisualFeedback: boolean
  enableSnapping: boolean
}

export default function PanelLayout({ mode, projectInfo }: PanelLayoutProps) {
  // Core state
  const [panels, setPanels] = useState<Panel[]>([])
  const [selectedPanelId, setSelectedPanelId] = useState<string | null>(null)
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false)
  const [isAIChatOpen, setIsAIChatOpen] = useState(false)
  const [isMounted, setIsMounted] = useState(false)
  const [isFullscreen, setIsFullscreen] = useState(false)
  const [isControlPanelCollapsed, setIsControlPanelCollapsed] = useState(false)
  const [isSettingsOpen, setIsSettingsOpen] = useState(false)

  // Performance optimizations
  const containerRef = useRef<HTMLDivElement>(null)
  const stageRef = useRef<any>(null)
  const animationFrameRef = useRef<number>()
  const lastDragTimeRef = useRef<number>(0)
  const DRAG_THROTTLE_MS = 16 // ~60fps

  // Resize settings
  const [resizeSettings, setResizeSettings] = useState<ResizeSettings>({
    minWidth: 50,
    minHeight: 50,
    maxWidth: 1000,
    maxHeight: 1000,
    lockAspectRatio: false,
    aspectRatio: 2.5, // Standard panel ratio
    snapToGrid: true,
    gridSize: GRID_CELL_SIZE_FT,
    snapToOtherPanels: true,
    snapThreshold: SNAP_THRESHOLD_FT,
    enableVisualFeedback: true,
    enableSnapping: true
  })

  // Zoom/Pan hook
  const {
    containerSize,
    viewportSize,
    setViewportSize,
    zoomIn,
    zoomOut,
    fitToExtent,
    toWorld,
    toScreen,
    isDragging,
    setIsDragging,
    scale
  } = useZoomPan({
    worldWidth: WORLD_WIDTH_FT,
    worldHeight: WORLD_HEIGHT_FT,
    viewportWidth: 800,
    viewportHeight: 600,
    initialFit: 'extent'
  })

  // Flexible resize hook
  const {
    isResizing,
    resizeResult,
    visualFeedback,
    startResize,
    updateResize,
    endResize,
    cancelResize,
    getResizeCursor,
    getResizeHandles
  } = useFlexibleResize({
    panels,
    onPanelUpdate: setPanels,
    constraints: {
      minWidth: resizeSettings.minWidth,
      minHeight: resizeSettings.minHeight,
      maxWidth: resizeSettings.maxWidth,
      maxHeight: resizeSettings.maxHeight,
      lockAspectRatio: resizeSettings.lockAspectRatio,
      aspectRatio: resizeSettings.aspectRatio,
      snapToGrid: resizeSettings.snapToGrid,
      gridSize: resizeSettings.gridSize,
      snapToOtherPanels: resizeSettings.snapToOtherPanels,
      snapThreshold: resizeSettings.snapThreshold
    },
    enableVisualFeedback: resizeSettings.enableVisualFeedback,
    enableSnapping: resizeSettings.enableSnapping
  })

  // Initialize with sample panels in auto mode
  useEffect(() => {
    if (mode === 'auto' && panels.length === 0) {
      setPanels([
        {
          id: '1',
          date: '2024-05-14',
          panelNumber: '1A',
          length: 100,
          width: 40,
          height: 100,
          rollNumber: 'R-101',
          location: 'Northeast corner',
          x: 50,
          y: 50,
          shape: 'rectangle',
          rotation: 0,
          fill: '#E3F2FD',
          color: '#E3F2FD',
          meta: { repairs: [], location: { x: 50, y: 50 } }
        },
        {
          id: '2',
          date: '2024-05-14',
          panelNumber: '2A',
          length: 100,
          width: 40,
          height: 100,
          rollNumber: 'R-102',
          location: 'Adjacent to 1A',
          x: 150,
          y: 50,
          shape: 'rectangle',
          rotation: 0,
          fill: '#BBDEFB',
          color: '#BBDEFB',
          meta: { repairs: [], location: { x: 150, y: 50 } }
        }
      ])
    }
  }, [mode, panels.length])

  // Fullscreen state sync
  useEffect(() => {
    const handler = () => {
      const fsElement = document.fullscreenElement
      setIsFullscreen(Boolean(fsElement && containerRef.current && fsElement === containerRef.current))
      // Trigger a viewport recalc shortly after toggle
      setTimeout(() => {
        if (containerRef.current) {
          const rect = containerRef.current.getBoundingClientRect()
          setViewportSize(Math.max(100, Math.floor(rect.width)), Math.max(100, Math.floor(rect.height))
        }
      }, 50)
    }
    document.addEventListener('fullscreenchange', handler)
    return () => document.removeEventListener('fullscreenchange', handler)
  }, [setViewportSize])

  // Mount effect
  useEffect(() => {
    setIsMounted(true)
  }, [])

  // Viewport size management
  useEffect(() => {
    if (!containerRef.current) return
    const update = () => {
      const rect = containerRef.current!.getBoundingClientRect()
      const w = Math.max(100, Math.floor(rect.width))
      const h = Math.max(100, Math.floor(rect.height))
      setViewportSize(w, h)
    }
    update()
    const ro = new ResizeObserver(update)
    ro.observe(containerRef.current)
    return () => ro.disconnect()
  }, [setViewportSize])

  // Panel interaction handlers
  const handlePanelClick = useCallback((panelId: string) => {
    setSelectedPanelId(panelId === selectedPanelId ? null : panelId)
  }, [selectedPanelId])

  const handlePanelDragEnd = useCallback((panelId: string, newX: number, newY: number) => {
    const worldPos = toWorld(newX, newY)
    
    // Grid snapping
    let snappedX = worldPos.x
    let snappedY = worldPos.y
    
    if (resizeSettings.snapToGrid) {
      snappedX = Math.round(worldPos.x / resizeSettings.gridSize) * resizeSettings.gridSize
      snappedY = Math.round(worldPos.y / resizeSettings.gridSize) * resizeSettings.gridSize
    }
    
    // Edge-to-edge snapping with neighbors
    let finalX = snappedX
    let finalY = snappedY
    
    if (resizeSettings.snapToOtherPanels) {
      panels.forEach(otherPanel => {
        if (otherPanel.id === panelId) return
        
        const panel = panels.find(p => p.id === panelId)
        if (!panel) return
        
        // Snap to left edge
        if (Math.abs((snappedX + panel.width) - otherPanel.x) < resizeSettings.snapThreshold) {
          finalX = otherPanel.x - panel.width
        }
        // Snap to right edge
        if (Math.abs(snappedX - (otherPanel.x + otherPanel.width)) < resizeSettings.snapThreshold) {
          finalX = otherPanel.x + otherPanel.width
        }
        // Snap to top edge
        if (Math.abs((snappedY + panel.height) - otherPanel.y) < resizeSettings.snapThreshold) {
          finalY = otherPanel.y - panel.height
        }
        // Snap to bottom edge
        if (Math.abs(snappedY - (otherPanel.y + otherPanel.height)) < resizeSettings.snapThreshold) {
          finalY = otherPanel.y + otherPanel.height
        }
      })
    }
    
    setPanels(prev => prev.map(p => 
      p.id === panelId ? { ...p, x: finalX, y: finalY } : p
    ))
  }, [panels, toWorld, resizeSettings])

  const handleCreatePanel = useCallback((panelData: {
    date: string
    panelNumber: string
    length: number
    width: number
    rollNumber: string
    location: string
    shape: 'rectangle' | 'triangle' | 'circle'
    points?: number[]
    radius?: number
  }) => {
    const newPanel: Panel = {
      id: `panel-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      shape: panelData.shape === 'triangle' ? 'rightTriangle' : 'rectangle',
      x: 100,
      y: 100,
      width: panelData.width,
      height: panelData.length,
      length: panelData.length, // Keep for backward compatibility
      rotation: 0,
      fill: '#3b82f6',
      color: '#3b82f6',
      meta: {
        repairs: [],
        location: { x: 100, y: 100 }
      },
      // Legacy fields
      date: panelData.date,
      panelNumber: panelData.panelNumber,
      rollNumber: panelData.rollNumber,
      location: panelData.location
    }
    setPanels(prev => [...prev, newPanel])
    setIsCreateModalOpen(false)
  }, [])

  const handleDeletePanel = useCallback(() => {
    if (selectedPanelId) {
      setPanels(panels.filter(panel => panel.id !== selectedPanelId))
      setSelectedPanelId(null)
    }
  }, [selectedPanelId, panels])

  const handleExportToDXF = useCallback(() => {
    if (panels.length === 0) return
    
    const exportPanels = panels.map(panel => ({
      id: panel.id,
      panelNumber: panel.panelNumber || panel.id,
      length: panel.length,
      width: panel.width,
      x: panel.x,
      y: panel.y,
      rotation: panel.rotation || 0,
      shape: panel.shape === 'rightTriangle' ? 'right-triangle' : 
             panel.shape === 'square' ? 'rectangle' : panel.shape,
      meta: panel.meta || { repairs: [], location: { x: 0, y: 0 } }
    }))
    
    const exportProjectInfo = {
      projectName: projectInfo.projectName,
      location: projectInfo.location,
      description: projectInfo.description,
      manager: projectInfo.manager,
      material: projectInfo.material
    }
    
    exportToDXF(exportPanels, exportProjectInfo)
  }, [panels, projectInfo])

  const handleExportToJSON = useCallback(() => {
    if (panels.length === 0) return
    exportToJSON(panels as any, projectInfo)
  }, [panels, projectInfo])

  const handleImportExcel = useCallback(async (file: File) => {
    try {
      const importedPanels = await parseExcelPanels(file)
      // Convert PanelRecord[] to Panel[]
      const convertedPanels: Panel[] = importedPanels.map(record => ({
        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
        shape: 'rectangle' as const,
        x: 50 + (panels.length * 20),
        y: 50 + (panels.length * 15),
        width: record.width,
        height: record.length,
        length: record.length,
        rotation: 0,
        color: '#3b82f6',
        fill: '#3b82f6',
        meta: {
          repairs: [],
          airTest: { result: 'pending' }
        },
        date: record.date,
        panelNumber: record.panelNumber,
        rollNumber: record.rollNumber,
        location: record.location
      }))
      setPanels(convertedPanels)
    } catch (error) {
      console.error('Error importing Excel file:', error)
    }
  }, [panels])

  const handleGenerateTemplate = useCallback(() => {
    generateTemplateFile()
  }, [])

  const handleAssignRollNumbers = useCallback(() => {
    const panelsWithRollNumbers = assignRollNumbersWestToEast(panels as any)
    setPanels(panelsWithRollNumbers as any)
  }, [panels])

  const handleReset = useCallback(() => {
    setPanels([])
    setSelectedPanelId(null)
  }, [])

  const toggleFullscreen = useCallback(async () => {
    try {
      if (!document.fullscreenElement) {
        await containerRef.current?.requestFullscreen?.()
      } else {
        await document.exitFullscreen?.()
      }
    } catch (e) {
      setIsFullscreen(prev => !prev)
    }
  }, [])

  // Optimized grid lines with viewport culling
  const gridLines = useMemo(() => {
    const lines: JSX.Element[] = []
    const buffer = 200 // Extra margin for smooth scrolling
    
    const startX = Math.max(0, Math.floor((viewportSize.x - buffer) / GRID_CELL_SIZE_FT) * GRID_CELL_SIZE_FT)
    const endX = Math.min(WORLD_WIDTH_FT, Math.ceil((viewportSize.x + viewportSize.width + buffer) / GRID_CELL_SIZE_FT) * GRID_CELL_SIZE_FT)
    const startY = Math.max(0, Math.floor((viewportSize.y - buffer) / GRID_CELL_SIZE_FT) * GRID_CELL_SIZE_FT)
    const endY = Math.min(WORLD_HEIGHT_FT, Math.ceil((viewportSize.y + viewportSize.height + buffer) / GRID_CELL_SIZE_FT) * GRID_CELL_SIZE_FT)
    
    for (let gx = startX; gx <= endX; gx += GRID_CELL_SIZE_FT) {
      lines.push(
        <Line 
          key={`gv-${gx}`} 
          points={[gx, startY, gx, endY]} 
          stroke="#e5e7eb" 
          strokeWidth={1} 
          listening={false} 
        />
      )
    }
    for (let gy = startY; gy <= endY; gy += GRID_CELL_SIZE_FT) {
      lines.push(
        <Line 
          key={`gh-${gy}`} 
          points={[startX, gy, endX, gy]} 
          stroke="#e5e7eb" 
          strokeWidth={1} 
          listening={false} 
        />
      )
    }
    
    // Draw axes with better visibility
    lines.push(
      <Line key="x-axis" points={[startX, 0, endX, 0]} stroke="#999" strokeWidth={2} listening={false} />,
      <Line key="y-axis" points={[0, startY, 0, endY]} stroke="#999" strokeWidth={2} listening={false} />
    )
    
    return lines
  }, [viewportSize])

  // Panel rendering with performance optimizations
  const renderPanel = useCallback((panel: Panel) => {
    const isSelected = panel.id === (selectedPanelId || '')
    const screenPos = toScreen({ x: panel.x || 0, y: panel.y || 0 })
    const screenSize = { 
      width: (panel.width || 0) * (scale || 1), 
      height: (panel.height || 0) * (scale || 1) 
    }
    
    let panelElement: JSX.Element
    
    switch (panel.shape) {
      case 'square':
        const size = Math.min(panel.width || 0, panel.height || 0) * (scale || 1)
        panelElement = (
          <Rect
            x={screenPos.x}
            y={screenPos.y}
            width={size}
            height={size}
            fill={isSelected ? '#ef4444' : panel.fill || '#3b82f6'}
            stroke={isSelected ? '#dc2626' : '#1e40af'}
            strokeWidth={isSelected ? 3 : 2}
            cornerRadius={4}
            draggable
            onDragEnd={(e: any) => {
              const pos = e.target.position()
              handlePanelDragEnd(panel.id || '', pos.x, pos.y)
            }}
            onClick={() => handlePanelClick(panel.id || '')}
          />
        )
        break
        
      case 'rightTriangle':
        const points = [
          screenPos.x || 0, (screenPos.y || 0) + (screenSize.height || 0),
          (screenPos.x || 0) + (screenSize.width || 0), (screenPos.y || 0) + (screenSize.height || 0),
          (screenPos.x || 0) + (screenSize.width || 0), screenPos.y || 0
        ]
        panelElement = (
          <Group
            x={0}
            y={0}
            draggable
            onDragEnd={(e: any) => {
              const pos = e.target.position()
              handlePanelDragEnd(panel.id || '', pos.x, pos.y)
            }}
            onClick={() => handlePanelClick(panel.id || '')}
          >
            <Line
              points={points}
              fill={isSelected ? '#ef4444' : panel.fill || '#3b82f6'}
              stroke={isSelected ? '#dc2626' : '#1e40af'}
              strokeWidth={isSelected ? 3 : 2}
              closed
            />
          </Group>
        )
        break
        
      default: // rectangle
        panelElement = (
          <Rect
            x={screenPos.x}
            y={screenPos.y}
            width={screenSize.width}
            height={screenSize.height}
            fill={isSelected ? '#ef4444' : panel.fill || '#3b82f6'}
            stroke={isSelected ? '#dc2626' : '#1e40af'}
            strokeWidth={isSelected ? 3 : 2}
            cornerRadius={4}
            draggable
            onDragEnd={(e: any) => {
              const pos = e.target.position()
              handlePanelDragEnd(panel.id || '', pos.x, pos.y)
            }}
            onClick={() => handlePanelClick(panel.id || '')}
          />
        )
    }
    
    return (
      <Group key={panel.id || 'unknown'}>
        {panelElement}
        {/* Panel Label */}
        <Text
          x={(screenPos.x || 0) + 5}
          y={(screenPos.y || 0) + 5}
          text={panel.panelNumber || panel.id || 'Unknown'}
          fontSize={12}
          fill="#ffffff"
          stroke="#000000"
          strokeWidth={0.5}
          listening={false}
        />
      </Group>
    )
  }, [selectedPanelId, toScreen, scale, handlePanelDragEnd, handlePanelClick])

  return (
    <div className="flex flex-row gap-0 w-full h-screen">
      {/* Collapsible Control Panel */}
      <div className={`bg-white border-r border-neutral-200 shadow-lg transition-all duration-300 ease-in-out ${
        isControlPanelCollapsed ? 'w-16' : 'w-80'
      }`}>
        <div className="flex flex-col h-full">
          {/* Header */}
          <div className="flex items-center justify-between p-4 border-b border-neutral-200">
            {!isControlPanelCollapsed && (
              <h3 className="font-semibold text-neutral-800">Controls</h3>
            )}
            <button
              onClick={() => setIsControlPanelCollapsed(!isControlPanelCollapsed)}
              className="p-2 rounded hover:bg-neutral-100"
            >
              {isControlPanelCollapsed ? <ChevronRight size={16} /> : <ChevronLeft size={16} />}
            </button>
          </div>

          {/* Control Content */}
          <div className="flex-1 p-4 space-y-4 overflow-y-auto">
            {!isControlPanelCollapsed && (
              <>
                {/* Zoom Controls */}
                <div className="space-y-2">
                  <h4 className="text-sm font-medium text-neutral-700">Navigation</h4>
                  <div className="grid grid-cols-2 gap-2">
                    <Button size="sm" onClick={() => zoomIn()} className="flex items-center gap-2">
                      <ZoomIn size={14} />
                      Zoom +
                    </Button>
                    <Button size="sm" onClick={() => zoomOut()} className="flex items-center gap-2">
                      <ZoomOut size={14} />
                      Zoom -
                    </Button>
                  </div>
                  <Button size="sm" variant="outline" onClick={() => fitToExtent()} className="w-full">
                    Fit to View
                  </Button>
                </div>

                {/* Panel Actions */}
                <div className="space-y-2">
                  <h4 className="text-sm font-medium text-neutral-700">Panels</h4>
                  <Button 
                    size="sm" 
                    onClick={() => setIsCreateModalOpen(true)}
                    className="w-full flex items-center gap-2"
                  >
                    <Plus size={14} />
                    Add Panel
                  </Button>
                  <Button 
                    size="sm" 
                    variant="outline" 
                    onClick={handleDeletePanel}
                    disabled={!selectedPanelId}
                    className="w-full flex items-center gap-2"
                  >
                    <Trash2 size={14} />
                    Delete Panel
                  </Button>
                  <Button 
                    size="sm" 
                    variant="outline" 
                    onClick={handleAssignRollNumbers}
                    disabled={panels.length === 0}
                    className="w-full flex items-center gap-2"
                  >
                    <Edit3 size={14} />
                    Assign Roll Numbers
                  </Button>
                </div>

                {/* Export/Import */}
                <div className="space-y-2">
                  <h4 className="text-sm font-medium text-neutral-700">Data</h4>
                  <Button 
                    size="sm" 
                    variant="outline" 
                    onClick={handleExportToDXF}
                    disabled={panels.length === 0}
                    className="w-full flex items-center gap-2"
                  >
                    <Download size={14} />
                    Export DXF
                  </Button>
                  <Button 
                    size="sm" 
                    variant="outline" 
                    onClick={handleExportToJSON}
                    disabled={panels.length === 0}
                    className="w-full flex items-center gap-2"
                  >
                    <Download size={14} />
                    Export JSON
                  </Button>
                  <Button 
                    size="sm" 
                    variant="outline" 
                    onClick={handleGenerateTemplate}
                    className="w-full flex items-center gap-2"
                  >
                    <Download size={14} />
                    Excel Template
                  </Button>
                  <input
                    type="file"
                    accept=".xlsx,.xls"
                    onChange={(e) => e.target.files?.[0] && handleImportExcel(e.target.files[0])}
                    className="hidden"
                    id="excel-import"
                  />
                  <Button 
                    size="sm" 
                    variant="outline" 
                    onClick={() => document.getElementById('excel-import')?.click()}
                    className="w-full flex items-center gap-2"
                  >
                    <Download size={14} />
                    Import Excel
                  </Button>
                </div>

                {/* Settings */}
                <div className="space-y-2">
                  <h4 className="text-sm font-medium text-neutral-700">Settings</h4>
                  <Button 
                    size="sm" 
                    variant="outline" 
                    onClick={() => setIsSettingsOpen(!isSettingsOpen)}
                    className="w-full flex items-center gap-2"
                  >
                    <Settings size={14} />
                    {isSettingsOpen ? 'Hide Settings' : 'Show Settings'}
                  </Button>
                </div>

                {/* Settings Panel */}
                {isSettingsOpen && (
                  <Card className="mt-4">
                    <CardHeader>
                      <CardTitle className="text-sm">Resize Settings</CardTitle>
                    </CardHeader>
                    <CardContent className="space-y-4">
                      <div className="grid grid-cols-2 gap-2">
                        <div>
                          <Label className="text-xs">Min Width</Label>
                          <Input
                            type="number"
                            value={resizeSettings.minWidth}
                            onChange={(e) => setResizeSettings(prev => ({ 
                              ...prev, 
                              minWidth: parseInt(e.target.value) || 50 
                            }))}
                            className="h-8 text-xs"
                          />
                        </div>
                        <div>
                          <Label className="text-xs">Min Height</Label>
                          <Input
                            type="number"
                            value={resizeSettings.minHeight}
                            onChange={(e) => setResizeSettings(prev => ({ 
                              ...prev, 
                              minHeight: parseInt(e.target.value) || 50 
                            }))}
                            className="h-8 text-xs"
                          />
                        </div>
                      </div>
                      
                      <div className="space-y-2">
                        <div className="flex items-center space-x-2">
                          <Switch
                            checked={resizeSettings.lockAspectRatio}
                            onCheckedChange={(checked) => setResizeSettings(prev => ({ 
                              ...prev, 
                              lockAspectRatio: checked 
                            }))}
                          />
                          <Label className="text-xs">Lock Aspect Ratio</Label>
                        </div>
                        {resizeSettings.lockAspectRatio && (
                          <Input
                            type="number"
                            step="0.1"
                            value={resizeSettings.aspectRatio}
                            onChange={(e) => setResizeSettings(prev => ({ 
                              ...prev, 
                              aspectRatio: parseFloat(e.target.value) || 1 
                            }))}
                            className="h-8 text-xs"
                            placeholder="Aspect Ratio"
                          />
                        )}
                      </div>

                      <div className="space-y-2">
                        <div className="flex items-center space-x-2">
                          <Switch
                            checked={resizeSettings.snapToGrid}
                            onCheckedChange={(checked) => setResizeSettings(prev => ({ 
                              ...prev, 
                              snapToGrid: checked 
                            }))}
                          />
                          <Label className="text-xs">Snap to Grid</Label>
                        </div>
                        {resizeSettings.snapToGrid && (
                          <Input
                            type="number"
                            value={resizeSettings.gridSize}
                            onChange={(e) => setResizeSettings(prev => ({ 
                              ...prev, 
                              gridSize: parseInt(e.target.value) || 100 
                            }))}
                            className="h-8 text-xs"
                            placeholder="Grid Size"
                          />
                        )}
                      </div>

                      <div className="space-y-2">
                        <div className="flex items-center space-x-2">
                          <Switch
                            checked={resizeSettings.snapToOtherPanels}
                            onCheckedChange={(checked) => setResizeSettings(prev => ({ 
                              ...prev, 
                              snapToOtherPanels: checked 
                            }))}
                          />
                          <Label className="text-xs">Snap to Panels</Label>
                        </div>
                        {resizeSettings.snapToOtherPanels && (
                          <Input
                            type="number"
                            value={resizeSettings.snapThreshold}
                            onChange={(e) => setResizeSettings(prev => ({ 
                              ...prev, 
                              snapThreshold: parseInt(e.target.value) || 4 
                            }))}
                            className="h-8 text-xs"
                            placeholder="Snap Threshold"
                          />
                        )}
                      </div>
                    </CardContent>
                  </Card>
                )}

                {/* Fullscreen Toggle */}
                <div className="space-y-2">
                  <h4 className="text-sm font-medium text-neutral-700">Display</h4>
                  <Button 
                    size="sm" 
                    variant="outline" 
                    onClick={toggleFullscreen}
                    className="w-full flex items-center gap-2"
                  >
                    <Maximize2 size={14} />
                    {isFullscreen ? 'Exit Full Screen' : 'Full Screen'}
                  </Button>
                </div>

                {/* AI Chat Toggle */}
                <div className="space-y-2">
                  <h4 className="text-sm font-medium text-neutral-700">AI Assistant</h4>
                  <Button 
                    size="sm" 
                    variant="outline" 
                    onClick={() => setIsAIChatOpen(!isAIChatOpen)}
                    className="w-full"
                  >
                    {isAIChatOpen ? 'Hide AI Chat' : 'Show AI Chat'}
                  </Button>
                </div>

                {/* Reset */}
                <div className="space-y-2">
                  <Button 
                    size="sm" 
                    variant="outline" 
                    onClick={handleReset}
                    className="w-full flex items-center gap-2"
                  >
                    <RotateCcw size={14} />
                    Reset
                  </Button>
                </div>
              </>
            )}

            {/* Collapsed Icons */}
            {isControlPanelCollapsed && (
              <div className="space-y-2">
                <button
                  onClick={() => zoomIn()}
                  className="w-10 h-10 flex items-center justify-center rounded hover:bg-neutral-100"
                  title="Zoom In"
                >
                  <ZoomIn size={16} />
                </button>
                <button
                  onClick={() => zoomOut()}
                  className="w-10 h-10 flex items-center justify-center rounded hover:bg-neutral-100"
                  title="Zoom Out"
                >
                  <ZoomOut size={16} />
                </button>
                <button
                  onClick={() => fitToExtent()}
                  className="w-10 h-10 flex items-center justify-center rounded hover:bg-neutral-100"
                  title="Fit to View"
                >
                  <Maximize2 size={16} />
                </button>
                <button
                  onClick={() => setIsCreateModalOpen(true)}
                  className="w-10 h-10 flex items-center justify-center rounded hover:bg-neutral-100"
                  title="Add Panel"
                >
                  <Plus size={16} />
                </button>
                <button
                  onClick={() => setIsSettingsOpen(!isSettingsOpen)}
                  className="w-10 h-10 flex items-center justify-center rounded hover:bg-neutral-100"
                  title="Settings"
                >
                  <Settings size={16} />
                </button>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Main Canvas Area */}
      <div className="flex-1 relative bg-[#f7f7f7]">
        {/* Panel Sidebar */}
        <PanelSidebar 
          panel={panels.find(p => p.id === selectedPanelId) || null} 
          onClose={() => setSelectedPanelId(null)} 
        />
        
        {/* Canvas Container */}
        <div 
          ref={containerRef} 
          className="w-full h-full"
          style={{ height: isFullscreen ? '100vh' : '100%' }}
        >
          {isMounted && (
            <Stage
              ref={stageRef}
              width={containerSize?.width || 800}
              height={containerSize?.height || 600}
              onWheel={(e: any) => {
                e.evt.preventDefault()
                const scaleBy = 1.1
                const stage = e.target.getStage()
                const oldScale = stage.scaleX()
                const pointer = stage.getPointerPosition()
                
                if (!pointer) return
                
                const mousePointTo = {
                  x: (pointer.x - stage.x()) / oldScale,
                  y: (pointer.y - stage.y()) / oldScale,
                }
                
                const newScale = e.evt.deltaY < 0 ? oldScale * scaleBy : oldScale / scaleBy
                
                stage.scale({ x: newScale, y: newScale })
                
                const newPos = {
                  x: pointer.x - mousePointTo.x * newScale,
                  y: pointer.y - mousePointTo.y * newScale,
                }
                stage.position(newPos)
                stage.batchDraw()
              }}
              onMouseDown={(e: any) => {
                if (e.target === e.target.getStage()) {
                  setIsDragging(true)
                }
              }}
              onMouseUp={() => setIsDragging(false)}
              onMouseMove={(e: any) => {
                if (!isDragging) return
                
                const stage = e.target.getStage()
                if (!stage) return
                
                const pointer = stage.getPointerPosition()
                if (!pointer) return
                
                const dx = pointer.x - stage.x()
                const dy = pointer.y - stage.y()
                
                stage.x(dx)
                stage.y(dy)
                stage.batchDraw()
              }}
              onDoubleClick={(e: any) => {
                if (e.target === e.target.getStage()) {
                  fitToExtent()
                }
              }}
            >
              <Layer>
                {/* Grid Lines */}
                {gridLines}
                
                {/* Panels */}
                {panels && panels.length > 0 && panels.map(renderPanel)}
              </Layer>
            </Stage>
          )}
        </div>
      </div>

      {/* Modals */}
      {isCreateModalOpen && (
        <CreatePanelModal
          onClose={() => setIsCreateModalOpen(false)}
          onCreatePanel={handleCreatePanel}
        />
      )}
      
      <PanelAIChat
        projectInfo={projectInfo}
        panels={panels}
        setPanels={setPanels}
      />
    </div>
  )
}